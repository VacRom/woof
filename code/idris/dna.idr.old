module dna

import list
import pair
import ite
import bool

data base = A | T | C | G

complement_base: base -> base
complement_base A = T
complement_base T = A
complement_base C = G
complement_base _ = C

complement_strand: list base -> list base
complement_strand nil = nil
complement_strand (h::t) = map (complement_base) (h::t)

-- Do we really need to use mkPair? Given one strand of DNA we have
  -- all the information needed to write out either strands since they
  -- are always complements of one another.
  -- In other words, list base gives the exact same information as
  -- list (mkPair base base) [the only exception is knowing which
  -- strand is '1st' and '2nd' but this can be chosen arbitrarily].

--strand1: list base -> list base
--strand1 nil = nil
--strand1 (h::t) = h::(strand1 t)

--strand2: list base -> list base
--strand2 nil = nil
--strand2 (h::t) = (complement_base h)::(strand2 t)

strand1: list (pair base base) -> list base
strand1 nil = nil
strand1 ((mkPair h h')::t) = h::(strand1 t)

strand2: list (pair base base) -> list base
strand2 nil = nil
strand2 ((mkPair h h')::t) = h'::(strand2 t)

-- Easily done when we write the function pairUp
pairUp: base -> pair base base
pairUp a = (mkPair a (complement_base a))

complete: list base -> list (pair base base)
complete nil = nil
complete (h::t) = (map (pairUp) (h::t)) -- [A,T,C,G] -> [AT,TA,CG,GC]

-- We can also write this without map when we make the right hand
  -- side: (mkPair h (complement_base h))::complete(t)

-- NOTE on this last question I know that I have to be able to make a
  -- universal function for a given base type b, but I'm not able to
  -- get Idris to compile it. So for the meanwhile, I wrote out four
  -- cases specifically for each base type which does complie and
  -- correctly does what we want, using map and foldr.

convertA: base -> bool
convertA A = true
convertA _ = false
convertT: base -> bool
convertT T = true
convertT _ = false
convertC: base -> bool
convertC C = true
convertC _ = false
convertG: base -> bool
convertG G = true
convertG _ = false

reduceA: list base -> list base
reduceA nil = nil
reduceA (h::t) = list.filter convertA (h::t)
reduceT: list base -> list base
reduceT nil = nil
reduceT (h::t) = list.filter convertT (h::t)
reduceC: list base -> list base
reduceC nil = nil
reduceC (h::t) = list.filter convertC (h::t)
reduceG: list base -> list base
reduceG nil = nil
reduceG (h::t) = list.filter convertG (h::t)

baseNat: base -> Nat
baseNat _ = 1

NatBase: list base -> list Nat
NatBase nil = nil
NatBase (h::t) = map (baseNat) (h::t)

countBase: list Nat -> Nat
countBase nil = 0
countBase (h::t) = list.foldr (+) (0) (h::t)

countA: list base -> Nat
countA nil = 0
countA (h::t) = countBase (NatBase (reduceA (h::t)))
countT: list base -> Nat
countT nil = 0
countT (h::t) = countBase (NatBase (reduceT (h::t)))
countC: list base -> Nat
countC nil = 0
countC (h::t) = countBase (NatBase (reduceC (h::t)))
countG: list base -> Nat
countG nil = 0
countG (h::t) = countBase (NatBase (reduceG (h::t)))
