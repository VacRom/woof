--specifications
import bool
import option
import pair
import list
import nat
import eq
import serialize

--implementations
import list
import ite

data set: (a: Type) -> Type = mkSet (list a)

-- The empty set of a
emptySet: set a
-- If s is empty then true, otherwise false
isEmpty: (s: set a) -> bool

-- Return the set, s union {v}
set_insert: (eq a) => a -> set a -> set a


-- Return the set, s - {v}
set_remove: (eq a) => (v: a) -> (s: set a) -> set a


-- Return the number of elements in s
set_cardinality: (s: set a) -> nat


-- If v is in s return true, otherwise false
set_member: (eq a) => (v: a) -> (s: set a) -> bool


-- Return union of s1 and s2
set_union: (eq a) => (s1: set a) -> (s2: set a) -> set a


-- Return the intersection of s1 and s2
set_intersection: (eq a) => (s1: set a) -> (s2: set a) -> set a


-- Return the set difference, s1 minus s2
set_difference: (eq a) => (s1: set a) -> (s2: set a) -> set a


-- Return true p is true for every v in s, otherwise false
set_forall: (p: a -> bool) -> (s: set a) -> bool


-- Return true if p is true for some v in s, otherwise else false
set_exists: (p: a -> bool) -> (s: set a) -> bool


-- If (set_exists p s), return (some v) such that (p v) is true, else
-- return none. We need to return an option because there might not be
-- an element in s with property p.  If there is such an element, we
-- call it a "witness to the property p."
set_witness: (p: a -> bool) -> (s: set a) -> option a


-- Return the cartesian product of s1 and s2. That is, return the
-- set of all pairs whose first element is taken from s1 and whose
-- second element is taken from s2. For example, the product of the
-- sets {1, 2} and {a, b} is { (1, a), (1, b), (2, a), (2, b) }.
set_product: (s1: set a) -> (s2: set b) -> set (pair a b)


-- Extra credit: Return the set of all sets of elements of s.
-- For example, the powerset of {1, 2, 3} is the following set:
-- { {}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3} }. The
-- cardinality of the powerset of a set of cardinality n is 2^n.
set_powerset: (s: set a) -> set (set a)


-- return true if s1 and s2 are equal, else false
set_eql: (eq a) => (s1: set a) -> (s2: set a) -> bool


-- Return a string representation of s
set_toString: (Serialize a) => set a -> String


------------------
-- class instances
------------------

-- Overloaded eql for sets: it just calls set_eql
-- Idris won't let us separate specification from
-- implementation for class instances, so we write
-- the implementation here, but it's just a call to
-- the specified (but not yet implemented) seq_eql.
-- You do not need to implement this class instance
-- any further in the code below.
instance (eq a) => eq (set a) where
  eql s1 s2 = set_eql s1 s2


-- Overloaded toString for sets, calls set_toString
-- The same comment right above applies here, too
instance (Serialize a) => Serialize (set a) where
  toString s = set_toString s


{-
*********************************************
*************** IMPLEMENTATION **************
*********************************************
-}

------------------------------------

-- Now we decide to represent sets as lists with an additional
-- "representation invariant": list must have no duplicate members.
-- We do not make this invariant explicit in the code here. Rather,
-- the programmer must bear it in mind when writing the code that
-- is to follow. Note that this code provides an *implementation*
-- for the abstract specification given above.
data set a = mkSet (list a)

------------------------------------

-- Similarly here we give a list-based, concrete implementation of
-- the specifid "emptySet" abstration, representing the empty set
-- with an empty list.
emptySet = mkSet nil

-------------------------------------

-- As a final note, here we provide a concrete implementation of the
-- isEmpty function specified above.
-- isEmpty: (s: set a) -> bool
isEmpty emptySet = true
isEmpty _ = false

-------------------------------------

-- And here t becomes absolutely clear that all we're doing here is
-- writing representation-(list)-specific implementation code that we
-- would ordinarily have put right under the type declaration for this
-- function. Separating this code allows us to see and to emphasie the
-- possibilities for separating specification and implementation ideas
-- when designing software.
-- set_insert: (v: a) -> (s: set a) -> set a
-- Return the set, s union {v}
set_insert v (mkSet l) = ite (member v l)
                             (mkSet l)
                             (mkSet (v::l))

-------------------------------------

-- Your task is to write and test implementations for the remaining
-- specified but unimplemented functions. We provide snippets and
-- hints in some cases that help you in this task.

-- In this case, we make it easier by providing an implementation for
-- you. However, the implementation uses a helper function that you
-- will need to write. In the following cases, you will need to work
-- out for yourself whether one or more helper functions will help.

-- helper function: return list l without value v
list_remove: (eq a) => (v: a) -> (l: list a) -> list a
list_remove v nil = nil
list_remove v (h::t) = ?your_code_here_1

-- set_remove: (eq a) => (v: a) -> (s: set a) -> set a
-- Return the set, s - {v}
set_remove v (mkSet l) = mkSet (list_remove v l)

-------------------------------------

-- Return the number of elements in s
-- set_cardinality: (s: set a) -> nat
-- relies on rep invariant
set_cardinality (mkSet l) = ?your_code_here_2

-------------------------------------

-- If v is in s return true, otherwise false
--set_member: (v: a) -> (s: set a) -> bool
set_member v (mkSet l) = ?your_code_here_3

-------------------------------------

-- Return union of s1 and s2
-- set_union: (s1: set a) -> (s2: set a) -> set a

-- hint, write a function, combine, that combines two
-- lists into one, avoiding duplicate elements

set_union (mkSet l1) (mkSet l2) = ?your_code_here_4

-------------------------------------

-- here we provide you with an incomplete helper function

intersect: (eq a) => list a -> list a -> list a
intersect nil _ = nil
intersect (h::t) l2 = ?your_code_here_5

-- Return the intersection of s1 and s2
-- set_intersection: (eq a) => list a -> list a -> list a
set_intersection (mkSet l1) (mkSet l2) = ?your_code_here_6

-------------------------------------

-- hint: write and use a list_difference helper function

-- Return the set difference, s1 minus s2
--set_difference: (eq a) => (s1: set a) -> (s2: set a) -> set a
set_difference (mkSet l1) (mkSet l2) = mkSet (?your_code_here_7)

-------------------------------------

-- hint: write one line of code using higher-order functions

-- Return true p is true for every v in s, otherwise false
-- set_forall: (p: a -> bool) -> (s: set a) -> bool

set_forall p (mkSet l) = ?your_code_here_8

-------------------------------------

-- hint: write one line of code using higher-order functions

-- Return true if p is true for some v in s, otherwise else false
-- set_exists: (p: a -> bool) -> (s: set a) -> bool
set_exists p (mkSet l) = ?your_code_here_9

-------------------------------------

--hint: write and use a list version of the witness function

-- If (set_exists p s), return (some v) such that (p v) is true,
-- else return none. We need to return an option because of course
-- in general there might not be an element in s with property p.
-- If there is one, we call it a "witness to the property, p."
-- set_witness: (p: a -> bool) -> (s: set a) -> option a

set_witness p (mkSet l) = ?your_code_here_10

-------------------------------------

-- hint: consider writing two levels of helper functions
-- the first takes two lists and returns a list of all pairs
-- the second takes one element and a list and returns all pairs
-- of that element with elements in the list

-- Return the cartesian product of s1 and s2. That is, return the
-- set of all pairs whose first element is taken from s1 and whose
-- second element is taken from s2. For example, the product of the
-- sets {1, 2} and {a, b} is { (1, a), (1, b), (2, a), (2, b) }.
-- set_product: (s1: set a) -> (s2: set b) -> set (pair a b)

set_product (mkSet la) (mkSet lb) = ?your_code_here_11

-------------------------------------

-- Extra credit: Return the set of all sets of elements of s.
-- For example, the powerset of {1, 2, 3} is the following set:
-- { {}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3} }. The
-- cardinality of the powerset of a set of cardinality n is 2^n.
-- set_powerset: (s: set a) -> set (set a)

-------------------------------------

-- Here you need to provide an implementation of set_eql. We
-- worked that out in class, so you might want to just use what
-- we already did.

-------------------------------------

-- Here you need to provide an implementation of set_toString.
-- Format a set like we did with a list, but use curly braces
-- instead of square brackets. Make sure that commas appear in
-- all and only the right places.

-------------------------------------

-- Yeah, you're done! Ok, not quite: Write tests for all of
-- the functions in this module. Put tests in set_adt_test.idr.
-- Indicate the expected value of each test in a corresponding
-- comment.

